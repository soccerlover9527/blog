<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>bin log - Tag - 融融冶冶黄</title><link>https://soccerlover9527.github.io/tags/bin-log/</link><description>bin log - Tag - 融融冶冶黄</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>soccerlover9527@gmail.com (融融冶冶黄)</managingEditor><webMaster>soccerlover9527@gmail.com (融融冶冶黄)</webMaster><lastBuildDate>Sun, 23 Apr 2023 20:55:10 +0800</lastBuildDate><atom:link href="https://soccerlover9527.github.io/tags/bin-log/" rel="self" type="application/rss+xml"/><item><title>Mysql 三大日志</title><link>https://soccerlover9527.github.io/posts/databases/mysql/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/</link><pubDate>Sun, 23 Apr 2023 20:55:10 +0800</pubDate><author>soccerlover</author><guid>https://soccerlover9527.github.io/posts/databases/mysql/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/</guid><description>Mysql 中常见的三种日志，二进制日志（binlog）事务日志（redo log 、undo log）
bin log binlog 是Mysql 数据用于记录数据库执行写入操作（新增编辑删除）操作，以二进制形式保存的逻辑日志（可以简单理解为存储的是执行的sql语句），注意这个日志是 Server 层记录的，无论任何引擎进行操作都会进行记录。
binlog可以用于主从复制或者数据恢复（mysqlbinlog工具）中。有三种写入模式
statement模式 每一条修改数据的sql都会记录到 binlog 中，slave 在复制的时候，会将该日志解析为相同的 sql 在slave中进行执行。
优点：不需要记录每一行的具体变化，大大减少了每条日志的大小，提高了IO效率和传输性能 缺点：如果sql 语句中包含有与当前环境有关的函数，例如：date(),sleep() 等，会造成主从数据不一致 ROW模式 基于行的复制，不记录每条 sql 语句的上下文信息，仅需要记录哪条数据被修改了，修改后的内容是什么，不会与上下文或者环境相关。
优点：row 日志记录仅仅记录了哪行记录的修改后的值，不会出现函数调用导致主从数据不一致的问题 缺点：如果该条sql修改了大量行的多个字段，会导致产生大量的bin log日志。 Mixed 模式 混合模式是上面两种模式优劣结合的折中产物，在Mixed模式下，server 会对每条 sql 进行分析，根据不同sql 走不同的模式进行日志记录。
redo log redo log 是 InnoDB 特有的用来保证事务持久性的日志。
持久性 redo log 保证了事务的持久性，对于一个事务来说，只要提交成功，对于数据库的修改就会被永久保留下来了，不可能因为任何原因回到原来的状态。
我们都知道，数据记录是保存在数据页上面，如果每次事务提交都将事务所涉及到的数据页全部写入磁盘当中，就能保证事务的持久性，但是很明显这个方法会引起严重的性能问题：
一个事务可能只会影响一个数据页中一条记录，为了保证持久性将整个数据页重新刷入磁盘太浪费磁盘IO资源 如果事务涉及很多个数据且这些数据分散在很多数据页上，这些数据页在物理上并不是连续的，导致一次事务提交大量数据页随机写 所以基于 WAL（write ahead log）这种设计思想，对于数据文件修改前，先记录修改日志，这个日志是顺序写的，最大限度保证这个日志的写入效率。
redo log 如何保证持久性的 当数据库对数据进行修改的时候，需要把数据从磁盘读入 buffer pool 中，然后在buffer pool 中对数据进行修改，这个时候buffer pool 中的数据和磁盘上的数据页内容不一致，这个时候称 buffer pool 中被修改的页为脏页（dirty page）。redo log 此时会同时记录事务对数据页做了哪些修改，产生一个 redo log 日志，然后写入redo log buffer 中，后续某一个时间点写入到 redo log file 中。</description></item></channel></rss>